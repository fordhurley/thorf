package thorf

import (
	"bufio"
	"fmt"
	"io"
	"strconv"
	"strings"
)

// TokenType is the enum of possible types of Tokens.
type TokenType int

const (
	// Word is the name of an operation.
	Word TokenType = iota
	// Num is a number.
	Num
	// Def indicates the beginning of the definition for a new user-defined function.
	Def
	// End is a semicolon, ending a user-defined function definition.
	End
)

func (tt TokenType) String() string {
	switch tt {
	case Word:
		return "Word"
	case Num:
		return "Num"
	case Def:
		return "Def"
	case End:
		return "End"
	default:
		return fmt.Sprintf("TokenType(%d)", tt)
	}
}

// Token is an item produced by the Lexer.
type Token struct {
	Type TokenType
	word string
	num  int
}

func (t Token) String() string {
	switch t.Type {
	case Word:
		return fmt.Sprintf("Word(%s)", t.word)
	case Num:
		return fmt.Sprintf("Num(%d)", t.num)
	default:
		return t.Type.String()
	}
}

// Lexer produces a stream of Tokens from an input.
type Lexer struct {
	scanner *bufio.Scanner
	next    Token
}

// NewLexer returns a new Lexer to read from r.
func NewLexer(r io.Reader) *Lexer {
	s := bufio.NewScanner(r)
	s.Split(bufio.ScanWords)
	return &Lexer{
		scanner: s,
	}
}

// Scan advances the Lexer, which will then be available through the Token
// method. It returns false when the end of the input has been reached or an
// error occurs. After Scan returns false, call Err to determine if it was
// because of an error.
func (l *Lexer) Scan() bool {
	if !l.scanner.Scan() {
		return false
	}

	w := l.scanner.Text()

	n, err := strconv.Atoi(w)
	if err == nil {
		l.next = Token{Type: Num, num: n}
		return true
	}

	if w == ":" {
		l.next = Token{Type: Def}
		return true
	}

	if w == ";" {
		l.next = Token{Type: End}
		return true
	}

	l.next = Token{Type: Word, word: strings.ToLower(w)}
	return true
}

// Token returns the most recent token generated by the call to Scan.
func (l *Lexer) Token() Token {
	return l.next
}

// Err returns the first non-EOF error that was encountered by the Lexer.
func (l *Lexer) Err() error {
	return l.scanner.Err()
}
